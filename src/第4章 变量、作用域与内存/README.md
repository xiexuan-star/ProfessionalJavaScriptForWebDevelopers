# 变量、作用域与内存

## 4.1 原始值与引用值

### 4.1.1 动态属性

### 4.1.2 复制值

引用复制(复杂数据类型) 与 副本复制(基本数据类型)

### 4.1.3 传递参数

### 4.1.4 确定类型

typeof 一般不用于对象的判断

instanceof 用于确定对象的类型

foo instanceof Object 用于判断对象

## 4.2 执行上下文与作用域

每个上下文都有一个关联的**变量对象(variable object)**

每个函数都有自己的上下文, 当代码执行流进入函数时, 函数的上下文被推到一个上下文栈上

函数执行完毕后, 上下文栈弹出该函数上下文, 将控制权返还给之前的执行上下文

上下文栈中的代码执行时, 会创建变量对象的一个**作用域链**, 它决定了各级上下文代码在访问变量和函数时的顺序

代码正在执行的上下文变量对象始终位于作用域链最前端, 如果上下文是函数, 则其活动对象用作变量对象

### 4.2.1 作用域链增强

with/catch

### 4.2.2 变量声明

var/let/const

let 也存在变量提升, 但由于TDZ的存在, 实际上不能在let声明前使用let变量

const 声明暗示变量的值是单一类型且不可修改, JavaScript运行时编译器可以将其所有实例替换成实际的值, 而不会通过查询表进行查找

访问局部变量比访问全局变量快, 但js引擎在标识符查找上作了很多优化, 这个差异是微不足道的

## 4.3 垃圾回收

自动内存管理

标记清理/引用计数

### 4.3.1 标记清理

变量进入上下文时会被打上标记, 运行GC时, 再次标记内存中的所有变量, 然后再将所有再上下文中(或引用)的变量的标记清除, 此时还有标记的变量即是需要清理的变量

### 4.3.2 引用计数

不好处理循环引用的问题

### 4.3.3 性能

垃圾回收的调度

### 4.3.4 内存管理

隐藏类与删除操作

V8引擎会将创建的对象与隐藏类关联从而提升性能

但是delete与动态添加属性会导致生成相同的隐藏类片段, 即多个实例不再共享隐藏类

内存泄漏/静态分配/对象池

静态分配: 通过优化代码使GC更少的运行(对象更替的速度)

```javascript
/**
 * @param a
 * @param b
 * @returns {Vector}
 * @description 假如函数被频繁调用, 那么对象更替速度便会很快, 浏览器会更频繁地安排GC
 */
function addVector(a, b) {
  let res = new Vector()
  res.x = a.x + b.x
  res.y = a.y + b.y
  return res;
}

/**
 * @param a
 * @param b
 * @param res
 * @returns {*}
 * @description 通过修改值的方式, 这样便不会有对象的更替
 */
function addVector2(a, b, res) {
  res.x = a.x + b.x
  res.y = a.y + b.y
  return res;
}

// 这类的优化非常极端, 一般情况不用考虑
```






